# Git 工作流程

## 本项目的工作流程

本项目采用 **dev-main** 双分支工作流，简单实用！

### 为什么这样设计？

**生活比喻：就像餐厅的厨房和餐桌**

```
🏠 dev (厨房)      → 制作菜品，可以试吃，不断改进
🍽️ main (餐厅)    → 上菜给客人，必须完美，不能出错
```

**好处：**
| ✅ 优点 | 说明 |
|-------|------|
| 🛡️ 线上稳定 | main分支永远是可用的 |
| 🧪 自由实验 | dev分支随便改，出问题不影响线上 |
| 🔄 快速回滚 | 出问题立即切回上一个main版本 |
| 👥 方便协作 | 大家在dev开发，一个人负责合并到main |

### 分支说明

```
┌─────────────────────────────────────┐
│      🍽️ main (生产分支 - 餐厅)         │
│   • 稳定的代码，可以展示给用户          │
│   • 推送触发自动部署到线上              │
│   • 不要直接在这里修改！               │
│   • 就像餐厅：菜品上桌后不能随便改       │
└─────────────────────────────────────┘
                 ↑ 合并（上菜）
┌─────────────────────────────────────┐
│      🏠 dev (开发分支 - 厨房)          │
│   • 日常开发都在这里                   │
│   • 推送不触发部署（安全）             │
│   • 可以随便试错                       │
│   • 就像厨房：随便试味道，不好重做       │
└─────────────────────────────────────┘
```

**什么时候用哪个分支？**

| 操作 | 用什么分支 | 说明 |
|------|-----------|------|
| 💻 日常开发 | `dev` | 写代码、改bug、加功能 |
| 🧪 本地测试 | `dev` | `pnpm docs:dev` 测试 |
| 🚀 发布上线 | `main` | 合并后推送到main |
| 🐛 紧急修复 | 先`main`后`dev` | 紧急情况特殊处理 |

### 完整工作流程图

```
┌─────────────────────────────────────────┐
│          开发阶段 (在dev分支)             │
├─────────────────────────────────────────┤
│  1. git checkout dev                     │
│  2. 编辑文件                             │
│  3. git add .                            │
│  4. git commit -m "描述"                 │
│  5. git push origin dev                  │
│  6. pnpm docs:dev (本地测试)              │
└─────────────────────────────────────────┘
                    ↓ 测试通过
┌─────────────────────────────────────────┐
│          发布阶段 (合并到main)            │
├─────────────────────────────────────────┤
│  7. git checkout main                    │
│  8. git pull origin main                 │
│  9. git merge dev                        │
│ 10. git push origin main  ← 触发部署     │
│ 11. git checkout dev (切回继续开发)       │
└─────────────────────────────────────────┘
```

### 命令示例（详细版）

```bash
# ==================== 阶段1：开发 ====================
# 1. 确保在dev分支
git checkout dev

# 2. 拉取最新代码（避免冲突）
git pull origin dev

# 3. 编辑文件...
# 比如：修改了 README.md

# 4. 查看改动（好习惯）
git status
git diff

# 5. 添加修改
git add .

# 6. 提交（写清楚做了什么）
git commit -m "docs: 更新Git使用说明"

# 7. 推送到远程（备份+同步）
git push origin dev

# ==================== 阶段2：测试 ====================
# 8. 本地测试
pnpm docs:dev

# 打开浏览器 http://localhost:5173
# 确认修改正确，没有bug

# ==================== 阶段3：发布 ====================
# 9. 确认无误后，切换到main
git checkout main

# 10. 拉取最新main代码
git pull origin main

# 11. 合并dev分支
git merge dev

# 12. 推送到main（触发自动部署）
git push origin main

# 13. 切回dev继续开发
git checkout dev
```

**时间线示例：**
```
早上9点:  在dev分支开发新功能
上午11点: 本地测试通过，推送到dev
下午2点:  确认没问题，合并到main
下午2点05: 自动部署完成，线上更新成功
下午3点:  切回dev，继续下一个功能
```

---

## 日常开发流程

### 🎯 场景1：开发新功能（标准流程）

**什么时候用？**
- 🎨 添加新功能（如：用户评论、购物车）
- 📝 添加新页面
- 🔧 重构代码

**完整步骤：**

```bash
# ──────────────────────────────────────
# 步骤 1：准备工作
# ──────────────────────────────────────
# 1.1 确保在dev分支
git checkout dev

# 1.2 拉取最新代码（非常重要！）
git pull origin dev
# 为什么？避免你的代码基于旧版本，合并时冲突

# 1.3 (可选) 创建功能分支
# 如果功能比较复杂，建议单独开分支
git checkout -b feature/comment-system
# 如果是简单改动，直接在dev上开发也行

# ──────────────────────────────────────
# 步骤 2：开始编码
# ──────────────────────────────────────
# 2.1 编辑文件...
# 比如：创建 comment-component.js

# 2.2 查看改了什么
git status
# 输出：
# modified:   index.html
# new file:   comment-component.js

# 2.3 (可选) 查看具体改动
git diff comment-component.js

# ──────────────────────────────────────
# 步骤 3：提交代码
# ──────────────────────────────────────
# 3.1 添加所有修改
git add .

# 3.2 提交（写清楚做了什么）
git commit -m "feat: 添加用户评论功能

- 支持发表评论
- 支持回复功能
- 添加表情支持
- 实现实时刷新"

# 3.3 推送到远程
# 如果在dev分支：
git push origin dev

# 如果在feature分支：
git push -u origin feature/comment-system

# ──────────────────────────────────────
# 步骤 4：本地测试
# ──────────────────────────────────────
# 4.1 启动开发服务器
pnpm docs:dev

# 4.2 在浏览器测试
# 打开 http://localhost:5173
# 确认：评论功能正常、没有bug

# ──────────────────────────────────────
# 步骤 5：代码审查 (如果是团队)
# ──────────────────────────────────────
# 5.1 在GitHub上创建 Pull Request
# 5.2 请同事审查代码
# 5.3 根据反馈修改
# 5.4 审查通过后合并

# ──────────────────────────────────────
# 步骤 6：合并到主分支
# ──────────────────────────────────────
# 6.1 切换到main分支
git checkout main

# 6.2 拉取最新代码
git pull origin main

# 6.3 合并dev（或feature）分支
git merge dev
# 或：git merge feature/comment-system

# 6.4 推送到main（触发自动部署）
git push origin main

# 6.5 切回dev继续开发
git checkout dev

# ──────────────────────────────────────
# 步骤 7：清理 (如果用了feature分支)
# ──────────────────────────────────────
# 7.1 删除本地feature分支
git branch -d feature/comment-system

# 7.2 删除远程feature分支
git push origin --delete feature/comment-system
```

**流程图：**
```
准备 → 编码 → 提交 → 测试 → 审查 → 合并 → 清理
 ↓      ↓      ↓      ↓      ↓      ↓      ↓
dev   dev   git   本地   PR   main  删除分支
```

---

### 🧪 场景2：本地测试

**为什么需要测试？**

| ❌ 不测试就发布 | ✅ 测试后再发布 |
|--------------|---------------|
| 可能线上崩溃 | 确保功能正常 |
| 用户看到bug | 提前发现问题 |
| 紧急回滚很尴尬 | 从容上线 |

**测试流程：**

```bash
# 1. 启动开发服务器
pnpm docs:dev

# 2. 打开浏览器
# http://localhost:5173

# 3. 测试清单
✅ 功能是否正常工作？
✅ 页面显示是否正确？
✅ 链接是否能点击？
✅ 移动端是否正常？
✅ 控制台有没有报错？

# 4. 测试通过后，准备发布
# Ctrl+C 停止服务器
```

**常见问题：**
- ❌ 页面打不开 → 检查端口是否被占用
- ❌ 样式乱了 → 清除浏览器缓存
- ❌ 报错 → 查看终端错误信息

---

### 👥 场景3：代码审查（团队协作）

**什么是代码审查（Code Review）？**

```
就像写作文让同学帮忙检查：
- 错别字（代码bug）
- 逻辑不通（逻辑错误）
- 可以写得更好（代码优化）
```

**什么时候需要？**
| 团队规模 | 是否需要审查 |
|---------|------------|
| 👤 个人项目 | ❌ 不需要 |
| 👥 2-5人小团队 | ✅ 建议 |
| 🏢 5+人团队 | ✅ 必须 |

**审查流程：**

```bash
# ──────────────────────────────────────
# 步骤 1：创建 Pull Request (PR)
# ──────────────────────────────────────
# 1.1 在GitHub上操作
# 进入项目页面 → 点击 "Pull requests"
# → "New pull request"
# → 选择分支：feature/comment-system → main

# 1.2 填写PR描述
# 标题：feat: 添加用户评论功能
# 内容：
#   - 做了什么：添加了完整的评论系统
#   - 如何测试：打开文章页面可以发表评论
#   - 注意事项：需要配合后端API

# ──────────────────────────────────────
# 步骤 2：同事审查
# ──────────────────────────────────────
# 2.1 同事会查看你的代码
# 2.2 提出修改建议
# 2.3 可能会评论：
#   "这里逻辑有点复杂，能否简化？"
#   "变量名可以更清晰"
#   "有没有考虑边界情况？"

# ──────────────────────────────────────
# 步骤 3：修改代码
# ──────────────────────────────────────
# 3.1 根据反馈修改
# 3.2 再次提交
git add .
git commit -m "fix: 根据审查建议优化代码"
git push

# ──────────────────────────────────────
# 步骤 4：合并
# ──────────────────────────────────────
# 4.1 审查通过后，同事点击 "Merge pull request"
# 4.2 代码自动合并到main分支
# 4.3 你可以删除feature分支
```

**审查的好处：**
| ✅ 好处 | 说明 |
|-------|------|
| 🐛 发现bug | 多双眼睛更保险 |
| 📚 知识共享 | 学习他人的好做法 |
| 🤝 团队协作 | 了解其他人在做什么 |
| 📖 代码记录 | PR讨论就是文档 |

---

### 🚀 场景4：发布到生产环境

**什么时候发布？**
- ✅ 本地测试通过
- ✅ 代码审查通过（如果需要）
- ✅ 确认没有问题

**发布流程：**

```bash
# ──────────────────────────────────────
# 步骤 1：切换到main分支
# ──────────────────────────────────────
git checkout main
# 为什么？main才是生产环境

# ──────────────────────────────────────
# 步骤 2：拉取最新代码
# ──────────────────────────────────────
git pull origin main
# 为什么？确保本地是最新的

# ──────────────────────────────────────
# 步骤 3：合并dev分支
# ──────────────────────────────────────
git merge dev
# 如果有冲突，先解决冲突

# ──────────────────────────────────────
# 步骤 4：推送到远程（触发部署）
# ──────────────────────────────────────
git push origin main
# ↑ 这一步会触发自动部署

# 等待几分钟，部署完成后：
# - 网站自动更新
# - 用户看到新功能

# ──────────────────────────────────────
# 步骤 5：切回dev继续开发
# ──────────────────────────────────────
git checkout dev
# 为什么？不要在main上开发
```

**发布检查清单：**
```
发布前检查：
✅ 本地测试通过
✅ 代码已合并到main
✅ 没有遗留的console.log
✅ 敏感信息已移除（密码、密钥）
✅ README已更新（如果需要）

发布后验证：
✅ 线上网站能访问
✅ 新功能正常工作
✅ 旧功能没有坏
✅ 没有报错（查看浏览器控制台）
```

---

## 常见场景

### 🚨 场景1：修复线上紧急问题

**场景：凌晨2点，网站崩溃了！**

```
紧急程度：🔴🔴🔴🔴🔴
用户反馈：网站打不开！
检查日志：发现是代码bug
紧急程度：每分钟都在损失用户！
```

**为什么需要特殊流程？**

| 正常流程 | 紧急修复流程 |
|---------|------------|
| dev → 测试 → main | main → 立即修复 |
| 花费1-2天 | 花费10-30分钟 |
| 适合计划内功能 | 适合紧急情况 |

**修复流程：**

```bash
# ──────────────────────────────────────
# 步骤 1：立即切换到main分支
# ──────────────────────────────────────
git checkout main
git pull origin main
# 确保拿到最新的生产代码

# ──────────────────────────────────────
# 步骤 2：创建紧急修复分支
# ──────────────────────────────────────
git checkout -b hotfix/login-crash
# 命名规范：hotfix/问题描述

# ──────────────────────────────────────
# 步骤 3：快速定位并修复问题
# ──────────────────────────────────────
# 3.1 查看错误日志
# 浏览器控制台、服务器日志

# 3.2 定位问题
# 比如：login.js 第50行，未检查空值

// 错误代码：
const user = getUser();
console.log(user.name);  // user可能是null，崩溃！

// 修复代码：
const user = getUser();
if (user) {
  console.log(user.name);  // 安全！
}

# 3.3 提交修复
git add login.js
git commit -m "hotfix: 修复登录页面崩溃问题

问题：未检查user对象是否存在
影响：用户无法登录
修复：添加空值检查
紧急程度：高"

# 3.4 推送到远程
git push -u origin hotfix/login-crash

# ──────────────────────────────────────
# 步骤 4：紧急发布到生产
# ──────────────────────────────────────
# 4.1 合并到main（立即！）
git checkout main
git merge hotfix/login-crash

# 4.2 打标签（记录这次修复）
git tag -a v1.0.1 -m "紧急修复登录崩溃"

# 4.3 推送到main（触发自动部署）
git push origin main --tags

# 💃 网站恢复了！

# ──────────────────────────────────────
# 步骤 5：同步修复到dev
# ──────────────────────────────────────
# 为什么？避免下次发布又出现这个问题
git checkout dev
git merge hotfix/login-crash
git push origin dev

# ──────────────────────────────────────
# 步骤 6：清理
# ──────────────────────────────────────
git branch -d hotfix/login-crash
git push origin --delete hotfix/login-crash
```

**时间线：**
```
00:00  发现问题
00:02  切换到main，创建hotfix分支
00:05  定位问题，修复代码
00:07  推送到远程
00:08  合并到main，触发部署
00:10  部署完成，问题解决！
00:12  同步到dev，清理分支
```

---

### 🔄 场景2：放弃本地修改

**场景：改错了，想重来**

```bash
# ──────────────────────────────────────
# 情况 1：只是修改了文件，还没add
# ──────────────────────────────────────
# 比如：编辑了 README.md，但改乱了

# 放弃单个文件的修改
git restore README.md
# 文件回到最近一次提交的状态

# 放弃所有修改
git restore .
# 所有文件都回到最近一次提交的状态

# 💡 生活比喻：
# 就像Word文档的"放弃所有修改"

# ──────────────────────────────────────
# 情况 2：已经add，但还没commit
# ──────────────────────────────────────
# 比如：git add . 后发现加错了

# 取消暂存
git reset HEAD README.md
# 文件从暂存区移除，但修改保留

# 如果要放弃修改：
git restore README.md

# ──────────────────────────────────────
# 情况 3：已经commit，但还没push
# ──────────────────────────────────────
# 比如：提交了，但发现代码有问题

# 回退到上一个提交（保留代码修改）
git reset --soft HEAD~1
# 提交撤销，代码还在，可以重新修改

# 回退到上一个提交（丢弃代码修改）
git reset --hard HEAD~1
# 提交撤销，代码也回到之前
# ⚠️ 谨慎使用！代码找不回来！

# ──────────────────────────────────────
# 情况 4：已经push（危险！）
# ──────────────────────────────────────
# 已经推送到远程，不能简单reset
# 需要 revert（创建新提交来撤销）

# 创建一个新提交来撤销之前的提交
git revert abc1234

# 💡 记忆技巧：
# restore  → 恢复文件（未提交）
# reset    → 回退提交（未推送）
# revert   → 撤销提交（已推送）
```

**何时使用哪个？**

| 命令 | 使用场景 | 危险程度 |
|------|---------|---------|
| `git restore file.txt` | 改错文件，想撤销 | ✅ 安全 |
| `git reset --soft HEAD~1` | 提交信息写错了 | ⚠️ 中等 |
| `git reset --hard HEAD~1` | 想回到之前版本 | 🔴 危险 |
| `git revert abc1234` | 已推送，想撤销 | ⚠️ 中等 |

---

### 🔄 场景3：同步远程更新

**场景：同事推送了代码，你需要同步**

```
你的本地：A → B → C (落后了)
远程仓库：A → B → C → D → E (更新了)
         ↑ 需要拉取 D 和 E
```

**为什么需要同步？**

| ❌ 不同步 | ✅ 同步后 |
|---------|---------|
| 代码过时 | 代码最新 |
| 合并时冲突多 | 合并时冲突少 |
| 可能重复工作 | 看到别人最新进展 |

**同步流程：**

```bash
# ──────────────────────────────────────
# 方法 1：pull (推荐新手)
# ──────────────────────────────────────
# 1. 拉取远程最新代码
git pull origin dev

# 如果有冲突，Git会自动合并
# 如果冲突无法自动解决，需要手动解决

# 💡 pull = fetch + merge
# fetch：下载远程代码
# merge：合并到本地

# ──────────────────────────────────────
# 方法 2：fetch + merge (更清晰)
# ──────────────────────────────────────
# 1. 下载远程代码（不合并）
git fetch origin

# 2. 查看有什么更新
git log HEAD..origin/dev
# 显示远程有哪些新提交

# 3. 手动合并
git merge origin/dev

# 💡 好处：可以先看看改了什么，再决定是否合并

# ──────────────────────────────────────
# 方法 3：fetch + rebase (保持历史整洁)
# ──────────────────────────────────────
# 1. 下载远程代码
git fetch origin

# 2. 变基（把你的提交放到最新代码之后）
git rebase origin/dev

# 💡 好处：历史记录是线性的，很清晰
# ⚠️ 注意：不要对已推送的提交使用
```

**三种方法对比：**

| 方法 | 优点 | 缺点 | 推荐场景 |
|------|------|------|---------|
| `git pull` | 简单，一步到位 | 不清楚发生了什么 | 新手、日常使用 |
| `fetch + merge` | 清晰，可控制 | 多两步操作 | 想先看更新内容 |
| `fetch + rebase` | 历史整洁 | 可能产生冲突 | 个人项目、小分支 |

**最佳实践：**
```bash
# 每天开始工作前
git checkout dev
git pull origin dev

# 合并分支前
git checkout main
git pull origin main
git merge dev
```

---

## 提交规范

### 为什么需要提交规范？

**就像给文件起名，要一眼看出内容**

```bash
# ❌ 不好的提交信息
git commit -m "修改"
git commit -m "update"
git commit -m "fix bug"
git commit -m "123"
# 问题：不知道改了什么、为什么改

# ✅ 好的提交信息
git commit -m "feat: 添加用户登录功能"
git commit -m "fix: 修复导航栏在移动端的显示问题"
git commit -m "docs: 更新Git工作流程说明"
# 好处：一目了然，方便查找和回滚
```

### 提交信息格式

**标准格式：类型(范围): 描述**

```bash
# 格式说明
类型(范围): 简短描述
  ↓      ↓      ↓
什么改了 哪部分 具体内容

# 实际示例
feat(用户): 添加登录功能
fix(导航): 修复导航栏显示错误
docs(首页): 更新README文档
```

**7种常用类型：**

| 类型 | 说明 | 示例 | 何时使用 |
|------|------|------|---------|
| 🎯 `feat` | 新功能 | `feat(用户): 添加头像上传` | 添加新功能 |
| 🐛 `fix` | 修复bug | `fix(登录): 修复验证错误` | 修复问题 |
| 📚 `docs` | 文档更新 | `docs(安装): 更新安装步骤` | 改文档 |
| 🎨 `style` | 代码格式 | `style(组件): 统一代码风格` | 格式调整 |
| 🔧 `refactor` | 重构 | `refactor(API): 优化请求逻辑` | 优化代码 |
| 🧪 `test` | 测试 | `test(工具): 添加单元测试` | 添加测试 |
| 📦 `chore` | 构建/工具 | `chore(deps): 更新依赖版本` | 配置文件 |

### 提交信息对比

| ✅ 好的提交 | ❌ 不好的提交 | 原因 |
|-----------|-------------|------|
| `feat: 添加用户登录功能` | `修改` | 太笼统 |
| `fix: 修复支付超时问题` | `fix bug` | 不清楚是什么bug |
| `docs: 更新README说明` | `update` | 看不出改了什么 |
| `refactor(api): 优化请求逻辑` | `优化代码` | 不知道优化了哪部分 |
| `style: 统一换行符为LF` | `格式调整` | 不知道具体改了什么 |

### 完整的提交信息示例

**简单提交：**
```bash
git commit -m "feat: 添加用户登录功能"
```

**详细提交（带正文）：**
```bash
git commit -m "feat: 添加用户登录功能

- 添加登录表单
- 实现邮箱/密码验证
- 添加记住密码功能
- 支持第三方登录

Closes #123"
```

**什么时候写详细描述？**
| 简单提交 | 详细提交 |
|---------|---------|
| 改动小 | 改动大 |
| 一目了然 | 需要解释 |
| 1个文件 | 多个文件 |
| 修改 | 新功能 |

### 提交频率建议

**就像存游戏，经常存档比较好**

| ❌ 不推荐 | ✅ 推荐 | 原因 |
|---------|--------|------|
| 一天一次提交 | 完成一个功能就提交 | 容易回滚 |
| 改了100个文件才提交 | 拆分成多个小提交 | 好定位问题 |
| 提交信息写"更新" | 每次提交写清楚做了什么 | 方便查找 |

**推荐的提交节奏：**
```bash
# 早上
git commit -m "feat: 添加登录表单"

# 中午
git commit -m "feat: 添加表单验证"

# 下午
git commit -m "feat: 添加错误处理"

# 晚上
git commit -m "feat: 添加登录成功跳转"

# 比一次提交"完成登录功能"好得多！
```

### 常见错误

**❌ 错误1：提交信息太笼统**
```bash
git commit -m "修改"  # 不好！
git commit -m "update"  # 不好！
```

**❌ 错误2：一次提交太多内容**
```bash
# 改了登录、注册、购物车、支付，一次性提交
git commit -m "完成多个功能"  # 不好！
```

**❌ 错误3：提交信息包含敏感信息**
```bash
git commit -m "fix: 移除密码=123456"  # 危险！密码泄露了！
```

**✅ 正确做法：**
```bash
# 1. 提交信息要具体
git commit -m "feat(登录): 添加密码强度检测"

# 2. 分批次提交
git commit -m "feat(登录): 添加登录表单"
git commit -m "feat(注册): 添加注册表单"
git commit -m "feat(购物车): 添加商品数量修改"

# 3. 检查是否有敏感信息
git diff  # 提交前检查！
```

---

## 最佳实践

### 1. 频繁提交，小步快跑

**为什么？就像存游戏，经常存档比较安全**

| ❌ 不推荐 | ✅ 推荐 | 原因 |
|---------|--------|------|
| 写完整个功能才提交 | 每个小功能点都提交 | 出问题容易定位 |
| 一次提交10个文件 | 拆分成多个提交 | 回滚方便 |
| 一天提交一次 | 完成一部分就提交 | 不会丢失进度 |

**实际对比：**

```bash
# ❌ 不好的做法
# 工作了8小时，改了20个文件，一次性提交
git commit -m "完成用户系统"
# 问题：如果有bug，很难定位是哪个改动引起的

# ✅ 好的做法
# 每完成一个小功能就提交
git commit -m "feat(用户): 添加登录表单"
git commit -m "feat(用户): 添加表单验证"
git commit -m "feat(用户): 添加错误提示"
git commit -m "feat(用户): 添加登录跳转"
# 好处：如果有问题，很容易定位到是哪一步出错的
```

**推荐的提交节奏：**
```
完成一个小功能 → 立即提交 → 继续下一个
    ↓              ↓            ↓
  30分钟         1分钟        继续工作
```

---

### 2. 推送前检查清单

**就像考试前检查试卷，避免低级错误**

```bash
# ──────────────────────────────────────
# 检查 1：查看当前状态
# ──────────────────────────────────────
git status
# 确认：
# ✓ 在正确的分支上
# ✓ 没有忘记添加的文件
# ✓ 没有不应该提交的文件

# ──────────────────────────────────────
# 检查 2：查看即将提交的内容
# ──────────────────────────────────────
git diff --staged
# 检查：
# ✓ 改动都是你想要的
# ✓ 没有敏感信息（密码、密钥）
# ✓ 没有调试代码（console.log）

# ──────────────────────────────────────
# 检查 3：查看提交历史
# ──────────────────────────────────────
git log --oneline -3
# 确认：
# ✓ 提交信息写得清楚
# ✓ 没有错误的提交
# ✓ 提交顺序合理

# ──────────────────────────────────────
# 检查 4：本地测试（如果需要）
# ──────────────────────────────────────
pnpm docs:dev
# 确认：
# ✓ 功能正常
# ✓ 没有报错

# ──────────────────────────────────────
# 最后：确认无误后推送
# ──────────────────────────────────────
git push
```

**常见错误检查：**

| ❌ 可能的错误 | ✅ 如何避免 |
|-------------|-----------|
| 提交了敏感信息 | `git diff` 检查 |
| 提交了调试代码 | 搜索 `console.log` |
| 提交信息写错 | `git commit --amend` 修改 |
| 推错分支 | `git status` 确认分支 |

---

### 3. 保持分支整洁

**就像定期打扫房间，保持清爽**

```bash
# ──────────────────────────────────────
# 习惯 1：定期同步主分支
# ──────────────────────────────────────
# 每天早上第一件事
git checkout dev
git pull origin main

# 好处：
# ✓ 代码保持最新
# ✓ 减少合并冲突
# ✓ 看到别人的最新进展

# ──────────────────────────────────────
# 习惯 2：及时删除已完成分支
# ──────────────────────────────────────
# 合并完成后，立即删除
git branch -d feature/xxx
git push origin --delete feature/xxx

# 好处：
# ✓ 分支列表清爽
# ✓ 避免误用旧分支
# ✓ 节省空间

# ──────────────────────────────────────
# 习惯 3：使用 rebase 保持历史整洁
# ──────────────────────────────────────
# 定期整理提交历史
git rebase -i HEAD~5
# 可以：
# - 合并多个提交
# - 修改提交信息
# - 删除错误提交

# ⚠️ 注意：只对自己未推送的分支做rebase
```

**分支健康度检查：**
```bash
# 查看所有分支
git branch -a

# 删除已合并的本地分支
git branch -d $(git branch --merged)

# 删除已合并的远程分支
git remote prune origin

# 查看哪些分支未合并
git branch --no-merged
```

---

### 4. 使用 .gitignore

**就像告诉收垃圾的人：这些不要扔**

```bash
# ──────────────────────────────────────
# 常见的 .gitignore 配置
# ──────────────────────────────────────

# 依赖包（node_modules等）
node_modules/
vendor/

# 构建产物
dist/
build/
*.min.js

# 系统文件
.DS_Store
Thumbs.db

# 日志文件
*.log
npm-debug.log*

# 环境变量（很重要！）
.env
.env.local
.env.*.local

# IDE配置
.vscode/
.idea/
*.swp
*.swo

# 临时文件
*.tmp
*.temp
```

**为什么需要 .gitignore？**

| ❌ 不使用 .gitignore | ✅ 使用 .gitignore |
|-------------------|------------------|
| 仓库巨大，下载慢 | 仓库小，下载快 |
| 提交变慢 | 提交快 |
| 可能泄露密钥 | 保护敏感信息 |
| 合并频繁冲突 | 减少冲突 |

**检查是否有不该提交的文件：**
```bash
# 查看未被跟踪的文件
git status

# 查看 .gitignore 生效情况
git check-ignore -v node_modules/

# 临时忽略某个文件
git update-index --assume-unchanged config.js
```

---

### 5. 分支管理规范

**团队协作时的黄金法则**

**分支命名规范：**
```bash
# ✅ 好的命名
feature/user-login        # 一目了然
fix/payment-timeout       # 知道是修什么
hotfix/critical-bug       # 知道很紧急

# ❌ 不好的命名
new-branch                # 太笼统
abc                       # 完全不知道干嘛
dev2                      # 容易混淆
```

**提交规范：**
```bash
# ✅ 好的提交
git commit -m "feat(用户): 添加登录功能"
git commit -m "fix(支付): 修复超时问题"

# ❌ 不好的提交
git commit -m "修改"
git commit -m "fix bug"
```

**合并规范：**
```bash
# ✅ 合并前先拉取
git pull origin main
git merge feature/xxx

# ❌ 直接合并（可能冲突）
git merge feature/xxx
```

---

### 6. 备份和恢复

**就像游戏存档，多几个备份更安全**

**本地备份：**
```bash
# 打包整个项目
tar -czf project-backup.tar.gz my-project/

# 或者使用文件管理器压缩
```

**远程备份：**
```bash
# 推送到多个远程仓库
git remote add backup https://github.com/xxx/project.git
git push backup main
```

**Git标签备份：**
```bash
# 为重要版本打标签
git tag -a v1.0.0 -m "第一个正式版本"
git push origin v1.0.0

# 查看所有标签
git tag

# 恢复到某个标签
git checkout v1.0.0
```

**💡 定期备份建议：**
- 每天推送到远程（GitHub/GitLab）
- 每周创建一个标签
- 重要版本立即打标签
- 关键时刻手动备份（压缩整个项目）

---

## 快速参考

### 🚀 开发流程速查表

**把这个打印出来贴在显示器旁边！**

```bash
# ──────────────────────────────────────
# 📋 日常开发（99%的情况）
# ──────────────────────────────────────
git checkout dev              # 1. 切换到dev分支
git pull origin dev           # 2. 拉取最新代码
# ... 编辑文件 ...
git add .                     # 3. 添加修改
git commit -m "feat: 描述"     # 4. 提交
git push origin dev           # 5. 推送
pnpm docs:dev                 # 6. 本地测试

# ──────────────────────────────────────
# 🚀 发布到生产
# ──────────────────────────────────────
git checkout main              # 1. 切换到main
git pull origin main           # 2. 拉取最新
git merge dev                  # 3. 合并dev
git push origin main           # 4. 推送（触发部署）
git checkout dev               # 5. 切回dev

# ──────────────────────────────────────
# 🔥 紧急修复
# ──────────────────────────────────────
git checkout main              # 1. 切到main
git pull origin main           # 2. 拉取最新
git checkout -b hotfix/bug     # 3. 创建修复分支
# ... 修复代码 ...
git add .                      # 4. 添加修改
git commit -m "hotfix: 修复"    # 5. 提交
git push origin hotfix/bug     # 6. 推送
git checkout main              # 7. 切回main
git merge hotfix/bug           # 8. 合并修复
git push origin main           # 9. 部署
```

---

### 📚 常用命令速查

**按使用频率排序：**

| 频率 | 命令 | 说明 | 示例 |
|-----|------|------|------|
| 🔥🔥🔥 | `git status` | 查看状态 | 最常用！ |
| 🔥🔥🔥 | `git add .` | 添加修改 | 几乎每次提交都用 |
| 🔥🔥🔥 | `git commit -m "msg"` | 提交 | 每天10次+ |
| 🔥🔥🔥 | `git push` | 推送 | 每天5次+ |
| 🔥🔥🔥 | `git pull` | 拉取 | 每天多次 |
| 🔥🔥 | `git checkout dev` | 切换分支 | 每天5次+ |
| 🔥🔥 | `git log --oneline -5` | 查看日志 | 每天多次 |
| 🔥🔥 | `git diff` | 查看改动 | 每天多次 |
| 🔥🔥 | `git branch` | 查看分支 | 每天3次+ |
| 🔥 | `git merge dev` | 合并分支 | 每天多次 |
| 🔥 | `git checkout -b feat/xxx` | 创建分支 | 每天1-2次 |
| 🔥 | `git restore file.txt` | 撤销修改 | 每天1-2次 |
| ⚡ | `git reset --soft HEAD~1` | 撤销提交 | 偶尔用 |
| ⚡ | `git branch -d feat/xxx` | 删除分支 | 偶尔用 |

---

### 🎯 场景-命令映射表

**不知道用什么命令？查这个表！**

| 我想... | 用什么命令 |
|---------|-----------|
| 查看改了什么 | `git status` |
| 撤销文件修改 | `git restore file.txt` |
| 撤销所有修改 | `git restore .` |
| 提交后发现忘了加文件 | `git add file.txt && git commit --amend` |
| 提交信息写错了 | `git commit --amend -m "新信息"` |
| 查看最近5次提交 | `git log --oneline -5` |
| 查看某次提交改了什么 | `git show abc1234` |
| 回到某个版本 | `git checkout abc1234` |
| 创建新分支 | `git checkout -b feature/xxx` |
| 切换分支 | `git checkout dev` |
| 删除本地分支 | `git branch -d feature/xxx` |
| 删除远程分支 | `git push origin --delete feature/xxx` |
| 合并分支 | `git merge dev` |
| 查看分支图 | `git log --graph --oneline --all` |

---

### ⚠️ 危险操作警告

**这些命令要谨慎使用！**

| 危险程度 | 命令 | 风险 | 替代方案 |
|---------|------|------|---------|
| 🔴🔴🔴 | `git reset --hard HEAD` | 丢弃所有修改 | `git restore .` |
| 🔴🔴🔴 | `git clean -fd` | 删除未跟踪文件 | 手动删除 |
| 🔴🔴 | `git push -f` | 强制推送（覆盖远程） | 不要用！ |
| 🔴🔴 | `git rebase` (已推送) | 改历史，导致冲突 | 用 merge |
| 🔴 | `git reset --hard HEAD~3` | 删除最近3次提交 | 用 `--soft` |
| 🔴 | `git branch -D xxx` | 强制删除分支 | 用 `-d` |

**使用危险命令前检查清单：**
```
□ 确认不需要这些代码了？
□ 已经备份到其他地方？
□ 确认命令的参数正确？
□ 知道如何恢复？
```

---

### 🆘 常见问题解决

**遇到问题？查这个表！**

| 问题 | 解决方案 |
|------|---------|
| 推送被拒绝 | 先 `git pull`，解决冲突后再 `git push` |
| 合并冲突 | 手动编辑冲突文件，然后 `git add` |
| 提交了不该提交的 | `git reset --soft HEAD~1` |
| 推送到错分支 | `git reset --hard HEAD~1 && git push -f` (危险！) |
| 忘记拉取最新代码 | `git pull origin dev` |
| 分支找不到 | `git fetch` 然后 `git branch -a` |
| 撤销文件修改 | `git restore file.txt` |
| 找回删除的文件 | `git checkout HEAD~1 file.txt` |
| 查看某次提交 | `git show abc1234` |

---

### 📞 获取帮助

**遇到问题不知道怎么办？**

```bash
# 查看命令帮助
git commit --help
git merge --help

# 查看所有命令
git help -g

# 查看当前状态（很有用）
git status
# Git会提示你该做什么

# 搜索解决方案
# Google: "git 如何撤销提交"
# Stack Overflow: 很详细的解答
```

**资源推荐：**
| 资源 | 网址 | 说明 |
|------|------|------|
| 📖 Git官方文档 | git-scm.com/doc | 最权威 |
| 🎥 视频教程 | B站搜索"Git教程" | 适合新手 |
| 💻 互动学习 | learngitbranching.js.org | 游戏化学习 |
| 📚 本项目文档 | (你正在看的) | 实战经验 |

---

## 🎉 恭喜你！

**掌握这些内容，你就已经超越了90%的Git用户！**

```
新手水平 ✅
├─ 了解基本概念
├─ 会使用 add/commit/push
└─ 知道分支是什么

进阶水平 ✅
├─ 掌握分支管理
├─ 会解决冲突
├─ 理解工作流程
└─ 遵循提交规范

高手水平 🔝
├─ 熟练使用 rebase
├─ 会恢复丢失的提交
├─ 理解 Git 内部原理
└─ 能帮助他人解决问题

你现在处于：进阶水平！✨
```

**下一步建议：**
1. 📖 多练习，形成肌肉记忆
2. 🤝 帮助同事解决Git问题
3. 📚 学习进阶技巧（Git高级命令）
4. 🎯 探索不同的工作流（Git Flow等）

---

## 下一步

掌握工作流程后，让我们学习[实战技巧 →](chapter-05)
