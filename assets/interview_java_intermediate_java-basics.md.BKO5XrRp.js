import{_ as a,o as n,c as i,ag as t}from"./chunks/framework.C63nTIu3.js";const c=JSON.parse('{"title":"Java中级面试题 - Java基础与并发编程","description":"","frontmatter":{"title":"Java中级面试题 - Java基础与并发编程"},"headers":[],"relativePath":"interview/java/intermediate/java-basics.md","filePath":"interview/java/intermediate/java-basics.md","lastUpdated":1770654977000}'),l={name:"interview/java/intermediate/java-basics.md"};function e(r,s,p,h,d,k){return n(),i("div",null,[...s[0]||(s[0]=[t(`<h1 id="java中级面试题-java基础与并发编程" tabindex="-1">Java中级面试题 - Java基础与并发编程 <a class="header-anchor" href="#java中级面试题-java基础与并发编程" aria-label="Permalink to &quot;Java中级面试题 - Java基础与并发编程&quot;">​</a></h1><blockquote><p><strong>难度等级</strong>：⭐⭐⭐ | <strong>出现频率</strong>：95% | <strong>建议掌握时间</strong>：2周</p></blockquote><h2 id="📚-本章目录" tabindex="-1">📚 本章目录 <a class="header-anchor" href="#📚-本章目录" aria-label="Permalink to &quot;📚 本章目录&quot;">​</a></h2><ul><li><a href="#一集合框架">一、集合框架</a></li><li><a href="#二多线程与并发">二、多线程与并发</a></li><li><a href="#三jvm基础">三、JVM基础</a></li><li><a href="#四java新特性">四、Java新特性</a></li></ul><hr><h2 id="一、集合框架" tabindex="-1">一、集合框架 <a class="header-anchor" href="#一、集合框架" aria-label="Permalink to &quot;一、集合框架&quot;">​</a></h2><h3 id="q1-hashmap的底层实现原理" tabindex="-1">Q1: HashMap的底层实现原理？ <a class="header-anchor" href="#q1-hashmap的底层实现原理" aria-label="Permalink to &quot;Q1: HashMap的底层实现原理？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A[HashMap结构] --&gt; B[数组+链表+红黑树]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A --&gt; C[数组 table]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A --&gt; D[链表 Node]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A --&gt; E[红黑树 TreeNode]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C --&gt; C1[默认容量16]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C --&gt; C2[负载因子0.75]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    C --&gt; C3[扩容阈值=容量×负载因子]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    D --&gt; D1[链表长度&gt;8]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    D --&gt; D2[转为红黑树]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    E --&gt; E1[树节点数&lt;6]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    E --&gt; E2[退化为链表]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>核心要点</strong>：</p><ul><li><strong>JDK 1.8</strong>：数组 + 链表 + 红黑树</li><li><strong>数组初始容量</strong>：16，负载因子0.75</li><li><strong>链表转红黑树</strong>：链表长度 ≥ 8 且数组长度 ≥ 64</li><li><strong>红黑树退化为链表</strong>：节点数 ≤ 6</li><li><strong>扩容时机</strong>：size &gt; capacity * loadFactor</li><li><strong>扩容机制</strong>：容量翻倍，重新计算所有元素的位置</li></ul><h3 id="q2-concurrenthashmap的实现原理-jdk-1-8" tabindex="-1">Q2: ConcurrentHashMap的实现原理（JDK 1.8）？ <a class="header-anchor" href="#q2-concurrenthashmap的实现原理-jdk-1-8" aria-label="Permalink to &quot;Q2: ConcurrentHashMap的实现原理（JDK 1.8）？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><table tabindex="0"><thead><tr><th>特性</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td><strong>底层结构</strong></td><td>Segment数组 + HashEntry数组 + 链表</td><td>Node数组 + 链表 + 红黑树</td></tr><tr><td><strong>锁粒度</strong></td><td>Segment（多个HashEntry）</td><td>单个Node（头节点）</td></tr><tr><td><strong>并发度</strong></td><td>默认16</td><td>理论上数组长度</td></tr><tr><td><strong>查询操作</strong></td><td>需要加锁（ReentrantLock）</td><td>无锁（volatile + CAS）</td></tr></tbody></table><p><strong>JDK 1.8 核心优化</strong>：</p><ul><li><strong>CAS + synchronized</strong>替代ReentrantLock</li><li><strong>头节点锁</strong>：只锁链表/红黑树的头节点</li><li><strong>无锁读</strong>：Node的val和next都用volatile修饰</li></ul><hr><h2 id="二、多线程与并发" tabindex="-1">二、多线程与并发 <a class="header-anchor" href="#二、多线程与并发" aria-label="Permalink to &quot;二、多线程与并发&quot;">​</a></h2><h3 id="q3-线程池的核心参数及工作原理" tabindex="-1">Q3: 线程池的核心参数及工作原理？ <a class="header-anchor" href="#q3-线程池的核心参数及工作原理" aria-label="Permalink to &quot;Q3: 线程池的核心参数及工作原理？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThreadPoolExecutor executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// corePoolSize: 核心线程数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// maximumPoolSize: 最大线程数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    60L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// keepAliveTime: 非核心线程空闲存活时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayBlockingQueue&lt;&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// workQueue: 任务队列</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { ... },     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// threadFactory: 线程工厂</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadPoolExecutor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CallerRunsPolicy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// handler: 拒绝策略</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>工作流程</strong>：</p><div class="language-mermaid vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    A[提交任务] --&gt; B{核心线程数已满?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B --&gt;|否| C[创建核心线程执行]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    B --&gt;|是| D{队列已满?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    D --&gt;|否| E[加入队列等待]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    D --&gt;|是| F{最大线程数已满?}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    F --&gt;|否| G[创建非核心线程执行]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    F --&gt;|是| H[执行拒绝策略]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>拒绝策略</strong>：</p><ul><li><code>AbortPolicy</code>（默认）：抛异常</li><li><code>CallerRunsPolicy</code>：调用者执行</li><li><code>DiscardPolicy</code>：直接丢弃</li><li><code>DiscardOldestPolicy</code>：丢弃队列最老的任务</li></ul><h3 id="q4-synchronized和reentrantlock的区别" tabindex="-1">Q4: synchronized和ReentrantLock的区别？ <a class="header-anchor" href="#q4-synchronized和reentrantlock的区别" aria-label="Permalink to &quot;Q4: synchronized和ReentrantLock的区别？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><table tabindex="0"><thead><tr><th>特性</th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td><strong>锁类型</strong></td><td>悲观锁、隐式锁</td><td>悲观锁、显式锁</td></tr><tr><td><strong>使用方式</strong></td><td>关键字</td><td>API调用</td></tr><tr><td><strong>公平性</strong></td><td>非公平锁</td><td>可选公平/非公平</td></tr><tr><td><strong>条件变量</strong></td><td>wait/notify</td><td>Condition支持多个条件</td></tr><tr><td><strong>可中断</strong></td><td>不可中断</td><td>lockInterruptibly()可中断</td></tr><tr><td><strong>锁超时</strong></td><td>不支持</td><td>tryLock()支持</td></tr></tbody></table><h3 id="q5-threadlocal的原理和内存泄漏问题" tabindex="-1">Q5: ThreadLocal的原理和内存泄漏问题？ <a class="header-anchor" href="#q5-threadlocal的原理和内存泄漏问题" aria-label="Permalink to &quot;Q5: ThreadLocal的原理和内存泄漏问题？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><p><strong>原理</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadLocal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 每个Thread维护一个ThreadLocalMap</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // key: ThreadLocal对象（弱引用）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // value: 线程的变量副本</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>内存泄漏原因</strong>：</p><ol><li><strong>ThreadLocalMap的key是弱引用</strong>：GC时会被回收</li><li><strong>value是强引用</strong>：如果不手动remove()，会导致内存泄漏</li><li><strong>线程池场景</strong>：线程复用，value一直存在</li></ol><p><strong>解决方案</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    threadLocal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    threadLocal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须手动清理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><hr><h2 id="三、jvm基础" tabindex="-1">三、JVM基础 <a class="header-anchor" href="#三、jvm基础" aria-label="Permalink to &quot;三、JVM基础&quot;">​</a></h2><h3 id="q6-jvm内存结构包含哪些部分" tabindex="-1">Q6: JVM内存结构包含哪些部分？ <a class="header-anchor" href="#q6-jvm内存结构包含哪些部分" aria-label="Permalink to &quot;Q6: JVM内存结构包含哪些部分？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>┌─────────────────────────────────────┐</span></span>
<span class="line"><span>│           JVM内存结构                │</span></span>
<span class="line"><span>├─────────────────────────────────────┤</span></span>
<span class="line"><span>│  程序计数器（Program Counter）        │  线程私有</span></span>
<span class="line"><span>│  虚拟机栈（VM Stack）                │  线程私有</span></span>
<span class="line"><span>│  本地方法栈（Native Method Stack）   │  线程私有</span></span>
<span class="line"><span>│  堆（Heap）                         │  线程共享</span></span>
<span class="line"><span>│  方法区（Method Area）              │  线程共享</span></span>
<span class="line"><span>└─────────────────────────────────────┘</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="q7-垃圾回收算法有哪些" tabindex="-1">Q7: 垃圾回收算法有哪些？ <a class="header-anchor" href="#q7-垃圾回收算法有哪些" aria-label="Permalink to &quot;Q7: 垃圾回收算法有哪些？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><ol><li><strong>标记-清除</strong>：标记后清除，产生碎片</li><li><strong>标记-整理</strong>：标记后整理，无碎片</li><li><strong>复制算法</strong>：复制到另一块，无碎片，浪费空间</li><li><strong>分代收集</strong>：新生代（复制），老年代（标记-清除/整理）</li></ol><p><strong>垃圾回收器对比</strong>：</p><table tabindex="0"><thead><tr><th>收集器</th><th>类型</th><th>侧重点</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>串行</td><td>单CPU，新生代</td></tr><tr><td><strong>Parallel</strong></td><td>并行</td><td>吞吐量优先</td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td>低停顿，老年代</td></tr><tr><td><strong>G1</strong></td><td>并发</td><td>可预测停顿</td></tr><tr><td><strong>ZGC</strong></td><td>并发</td><td>极低停顿（&lt;10ms）</td></tr></tbody></table><hr><h2 id="四、java新特性" tabindex="-1">四、Java新特性 <a class="header-anchor" href="#四、java新特性" aria-label="Permalink to &quot;四、Java新特性&quot;">​</a></h2><h3 id="q8-java-21虚拟线程是什么" tabindex="-1">Q8: Java 21虚拟线程是什么？ <a class="header-anchor" href="#q8-java-21虚拟线程是什么" aria-label="Permalink to &quot;Q8: Java 21虚拟线程是什么？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传统线程池模型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutorService executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newFixedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 问题：线程数量受限，上下文切换开销大</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 虚拟线程（Java 21）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutorService executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newVirtualThreadPerTaskExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 优势：轻量级，百万级并发，几乎无上下文切换开销</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>核心特点</strong>：</p><ul><li><strong>轻量级</strong>：虚拟线程占用的内存极小（几KB）</li><li><strong>数量无限</strong>：可创建百万级虚拟线程</li><li><strong>调度机制</strong>：由JVM调度，而非OS</li><li><strong>阻塞成本</strong>：阻塞时自动释放物理线程</li></ul><h3 id="q9-record类的使用场景" tabindex="-1">Q9: Record类的使用场景？ <a class="header-anchor" href="#q9-record类的使用场景" aria-label="Permalink to &quot;Q9: Record类的使用场景？&quot;">​</a></h3><p><strong>参考答案</strong>：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传统写法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 构造器、getter、equals、hashCode、toString...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Record写法（Java 14+）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">record</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y) {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>特点</strong>：</p><ul><li>不可变数据载体</li><li>自动生成构造器、getter、equals、hashCode、toString</li><li>可实现接口，但不能继承其他类</li></ul><hr><h2 id="📚-延伸阅读" tabindex="-1">📚 延伸阅读 <a class="header-anchor" href="#📚-延伸阅读" aria-label="Permalink to &quot;📚 延伸阅读&quot;">​</a></h2><ul><li><a href="./../advanced/microservices.html">高级面试题：微服务架构 →</a></li><li><a href="./../advanced/distributed-system.html">高级面试题：分布式系统 →</a></li><li><a href="./../advanced/project-interview.html">实战项目面试题 →</a></li></ul><hr><p><strong>更新时间</strong>：2026年2月 | <strong>版本</strong>：v2.0</p>`,63)])])}const g=a(l,[["render",e]]);export{c as __pageData,g as default};
